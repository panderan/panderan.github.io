<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Docker 是目前广泛应用的容器技术，它将容器内部的环境与主机进行隔离，使得只需分发容器边可运行多种应用程序并且免除了复杂的软件环境配置。在 Docker 中，主要通过 Linux Namespaces 功能来完成对容器和主机多种资源隔离，本文详述了 Linux Namespace 功能，并且演示了如何使勇 unshare 程序手工创建一个隔离环境。">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker Technology using Linux Namespaces">
<meta property="og:url" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/index.html">
<meta property="og:site_name" content="Deran Pan&#39;s Pages">
<meta property="og:description" content="Docker 是目前广泛应用的容器技术，它将容器内部的环境与主机进行隔离，使得只需分发容器边可运行多种应用程序并且免除了复杂的软件环境配置。在 Docker 中，主要通过 Linux Namespaces 功能来完成对容器和主机多种资源隔离，本文详述了 Linux Namespace 功能，并且演示了如何使勇 unshare 程序手工创建一个隔离环境。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/Docker-Technology-using-Linux-Namespaces/Docker01.png">
<meta property="og:image" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/DevOps1.png">
<meta property="og:image" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/ContinuousDeliveryToolLandscape-fullsize.jpg">
<meta property="og:image" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/Docker-Technology-using-Linux-Namespaces/Docker02.jpg">
<meta property="og:image" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/Docker-Technology-using-Linux-Namespaces/Docker03.jpg">
<meta property="og:image" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/docker-core-techs1.png">
<meta property="og:image" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/uts.jpg">
<meta property="og:image" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/user.jpg">
<meta property="og:image" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/ns.jpg">
<meta property="og:image" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/PID.jpg">
<meta property="og:image" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/docker_process.png">
<meta property="og:image" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/ipc.jpg">
<meta property="og:image" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/net.jpg">
<meta property="og:image" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/docker-veth.png">
<meta property="article:published_time" content="2018-12-29T13:57:34.000Z">
<meta property="article:modified_time" content="2022-01-01T14:07:40.317Z">
<meta property="article:author" content="Deran Pan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/Docker-Technology-using-Linux-Namespaces/Docker01.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Docker Technology using Linux Namespaces</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/projects_url">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2019/01/04/%E3%80%90%E6%96%87%E7%8C%AE%E7%BF%BB%E8%AF%91%E3%80%91Reference-Policy-for-Security-Enhanced-Linux/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2018/05/06/%E5%9C%A8CXX%E4%B8%AD%E7%94%A8%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&text=Docker Technology using Linux Namespaces"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&title=Docker Technology using Linux Namespaces"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&is_video=false&description=Docker Technology using Linux Namespaces"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Docker Technology using Linux Namespaces&body=Check out this article: https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&title=Docker Technology using Linux Namespaces"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&title=Docker Technology using Linux Namespaces"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&title=Docker Technology using Linux Namespaces"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&title=Docker Technology using Linux Namespaces"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&name=Docker Technology using Linux Namespaces&description=&lt;p&gt;Docker 是目前广泛应用的容器技术，它将容器内部的环境与主机进行隔离，使得只需分发容器边可运行多种应用程序并且免除了复杂的软件环境配置。在 Docker 中，主要通过 Linux Namespaces 功能来完成对容器和主机多种资源隔离，本文详述了 Linux Namespace 功能，并且演示了如何使勇 unshare 程序手工创建一个隔离环境。&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&t=Docker Technology using Linux Namespaces"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Docker-%E7%AE%80%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1. Docker 简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Docker-%E7%9A%84%E6%8A%80%E6%9C%AF%E6%94%AF%E6%92%91"><span class="toc-number">2.</span> <span class="toc-text">3. Docker 的技术支撑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Docker-vs-Hypervisor"><span class="toc-number">2.1.</span> <span class="toc-text">3.1 Docker vs Hypervisor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Docker-%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF"><span class="toc-number">2.2.</span> <span class="toc-text">3.2 Docker 中的关键技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-Namespaces"><span class="toc-number">2.2.1.</span> <span class="toc-text">3.2.1 Namespaces</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-Control-Groups"><span class="toc-number">2.2.2.</span> <span class="toc-text">3.2.2 Control Groups</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-Union-Filesystem"><span class="toc-number">2.2.3.</span> <span class="toc-text">3.2.3 Union Filesystem</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%9E%E9%AA%8C"><span class="toc-number">3.</span> <span class="toc-text">4. 实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%88%A9%E7%94%A8-Linux-%E4%B8%AD%E7%9A%84-Namespace-%E6%89%8B%E5%B7%A5%E5%BB%BA%E7%AB%8B%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83"><span class="toc-number">3.1.</span> <span class="toc-text">4.1 利用 Linux 中的 Namespace 手工建立容器环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Docker Technology using Linux Namespaces
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Deran Pan</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2018-12-29T13:57:34.000Z" itemprop="datePublished">2018-12-29</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/linux/">linux</a>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>Docker 是目前广泛应用的容器技术，它将容器内部的环境与主机进行隔离，使得只需分发容器边可运行多种应用程序并且免除了复杂的软件环境配置。在 Docker 中，主要通过 Linux Namespaces 功能来完成对容器和主机多种资源隔离，本文详述了 Linux Namespace 功能，并且演示了如何使勇 unshare 程序手工创建一个隔离环境。</p>
<span id="more"></span>
<h2 id="1-Docker-简述"><a href="#1-Docker-简述" class="headerlink" title="1. Docker 简述"></a>1. Docker 简述</h2><p><strong>Docker 产生的背景</strong></p>
<p>通常被开发的软件都将会运行在不同的平台和环境上，开发环境、测试环境、生产环境等等。在软件部署的过程中可能会需要配置各种各样的依赖库，数据库，Web服务器等等。即便软件本身没有任何的问题，正确的配置各个平台和环境也不是一件容易的事。</p>
<p>而随着互联网时代的高速发展，特别是面向普通的大众的软件产品，以其需求的不明确性和不稳定性，传统的软件开发模式变不在适用，如瀑布模型等。取而代之的则是所谓的敏捷开发，需要快速的交付能力和应对的需求的快速变更能力。实现最小原型，获取产品的即时反馈，并进行即时迭代。这就要求部署的更加平凡，这对于传统运维来讲是巨大的挑战的。开发的目的是交付新特性、修复Bug。而运维的目的是维持系统稳定性和可靠性。而对于快速部署这一需求的到来，激化了开发和运维之间的矛盾。因此，真正促使 Docker 技术的出现的原因正是开发和运维所面临的挑战。而 Docker 主要是解决目前在软件部署过程中开发环境和运维环境的一致性问题。使得开发环境与运维环境达到了很好的衔接，在部署应用上线时，不需要花费时间去处理环境的不兼容问题。</p>
<p>同时 Docker 也是实现 DevOps 的最佳解决方案。</p>
<p><strong>什么是 Docker</strong></p>
<p><img src="Docker-Technology-using-Linux-Namespaces/Docker01.png" alt="一张图说明 Docker" style="zoom: 67%;" /></p>
<ul>
<li><p>对软件和其依赖环境的标准化打包</p>
</li>
<li><p>应用之间相互隔离</p>
</li>
<li><p>共享一个OS Kernel</p>
</li>
<li><p>可以运行在很多主流操作系统上</p>
</li>
</ul>
<p><em>Docker 中 容器，镜像，仓库的概念及其操作（略）</em></p>
<p><strong>* DevOps</strong></p>
<p>DevOps 一词的来自于 Development 和 Operations 的组合，突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、发布更加快捷、频繁和可靠。但是 DevOps 至今缺乏一个明确的定义，不同角色所理解的 DevOps 并不同样。</p>
<img src="/2018/12/29/docker_technology-using-linux-namespaces/DevOps1.png" class="">
<p>从技术的角度来看，DevOps 更多的是一组技术实践，具体来讲就是 DevOps 工具链。工具的具体选择则需要根据具体情况而定。</p>
<img src="/2018/12/29/docker_technology-using-linux-namespaces/ContinuousDeliveryToolLandscape-fullsize.jpg" class="">
<p>涉及到 DevOps 通常有以下话题：</p>
<ul>
<li>高频部署</li>
<li>持续交付</li>
<li>云计算/虚拟化技术</li>
<li>基础设施即代码</li>
<li>Docker</li>
<li>自动化运维</li>
</ul>
<h2 id="3-Docker-的技术支撑"><a href="#3-Docker-的技术支撑" class="headerlink" title="3. Docker 的技术支撑"></a>3. Docker 的技术支撑</h2><p>Docker 的出现一定是因为开发和运维阶段确实需要一种虚拟化技术，解决开发和生产环境一致的问题。虽然这个需求推动着虚拟化技术的产生，但是如果没有合适的底层技术支撑，那么将任然都不到一个完美的产品。</p>
<h3 id="3-1-Docker-vs-Hypervisor"><a href="#3-1-Docker-vs-Hypervisor" class="headerlink" title="3.1 Docker vs Hypervisor"></a>3.1 Docker vs Hypervisor</h3><p>在了解 Docker 的技术支撑之前，先了解一下 Docker 和虚拟机之间的区别。</p>
<p><img src="Docker-Technology-using-Linux-Namespaces/Docker02.jpg" style="zoom: 50%;" /></p>
<p>同样，虚拟化技术也同样可以解决环境差异问题。在同一台物理机上安装多个虚拟机，应用则可以部署在每个独立的虚拟机中。但是相比较于容器技术轻量级，每一个虚拟机都需要一定资源来运行和维护自身的操作系统。当虚拟机数量增多，势必操作系统自身消耗的资源将大大增加。</p>
<p>容器技术与虚拟化技术并不冲突。如果将容器比作集装箱，那么虚拟化就相当于大货轮。将容器和虚拟机结合在一起使用，也是目前的主流做法。</p>
<p><img src="Docker-Technology-using-Linux-Namespaces/Docker03.jpg" style="zoom:50%;" /></p>
<h3 id="3-2-Docker-中的关键技术"><a href="#3-2-Docker-中的关键技术" class="headerlink" title="3.2 Docker 中的关键技术"></a>3.2 Docker 中的关键技术</h3><img src="/2018/12/29/docker_technology-using-linux-namespaces/docker-core-techs1.png" class="" alt="docker-core-techs1">
<h4 id="3-2-1-Namespaces"><a href="#3-2-1-Namespaces" class="headerlink" title="3.2.1 Namespaces"></a>3.2.1 Namespaces</h4><p>命名空间 (namespaces) 是 Linux 提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。在日常使用 Linux 桌面版时，通常没有运行多个完全分离的进程的需要。但是在服务器上运行多个服务，这些服务其实会相互影响的。每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件。在很多时候，这样是有风险的。在这种情况下，一旦服务器上的某一个服务被入侵，那么入侵者就能够访问当前机器上的所有服务和文件。此时就需求一种能够使得运行在同一台机器上的不同服务能够完全隔离的方法，就像运行在多台不同的机器上一样。而 Docker 就是通过 Linux 的 Namespaces 对不同的容器实现了隔离。</p>
<p><strong>/proc/[pid]/ns 目录</strong></p>
<p>每一个进程都有一个 /proc/[pid]/ns 目录，其中每一个文件都对应着一个 namespace。这些文件都是以连接文件的形式存在，并连接到对应的 namespace 类型和 inode 。如果两个进程在同一个命名空间，那么他们的 namespace 类型和 inode 数值将相同。这些值都可以使用 setns() 系统调用来设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">=&gt;  ~ ls -l /proc/$$/ns</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 panderan panderan 0 12月  3 18:10 cgroup -&gt; &#x27;cgroup:[4026531835]&#x27;</span><br><span class="line">lrwxrwxrwx 1 panderan panderan 0 12月  3 18:10 ipc -&gt; &#x27;ipc:[4026531839]&#x27;</span><br><span class="line">lrwxrwxrwx 1 panderan panderan 0 12月  3 18:10 mnt -&gt; &#x27;mnt:[4026531840]&#x27;</span><br><span class="line">lrwxrwxrwx 1 panderan panderan 0 12月  3 18:10 net -&gt; &#x27;net:[4026531993]&#x27;</span><br><span class="line">lrwxrwxrwx 1 panderan panderan 0 12月  3 18:10 pid -&gt; &#x27;pid:[4026531836]&#x27;</span><br><span class="line">lrwxrwxrwx 1 panderan panderan 0 12月  3 18:10 pid_for_children -&gt; &#x27;pid:[4026531836]&#x27;</span><br><span class="line">lrwxrwxrwx 1 panderan panderan 0 12月  3 18:10 user -&gt; &#x27;user:[4026531837]&#x27;</span><br><span class="line">lrwxrwxrwx 1 panderan panderan 0 12月  3 18:10 uts -&gt; &#x27;uts:[4026531838]&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Namespace Type</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>namespace</th>
<th>引入的相关内核版本</th>
<th>被隔离的全局系统资源</th>
<th>在容器语境下的隔离效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>mount</td>
<td>since linux 3.8</td>
<td>文件系统挂接点</td>
<td>每个容器能看到不同的文件系统层次结构。</td>
</tr>
<tr>
<td>uts</td>
<td>since linux 3.0</td>
<td>nodename 和 domainname</td>
<td>每个容器可以有自己的 hostname 和 domainame。</td>
</tr>
<tr>
<td>IPC</td>
<td>since linux 3.0</td>
<td>特定的进程间通信资源</td>
<td>每个容器有其自己的 System V IPC 和 POSIX 消息队列文件系统，在同一个 IPC namespace 的进程之间才能互相通信。</td>
</tr>
<tr>
<td>PID</td>
<td>since linux 3.8</td>
<td>进程 ID 数字空间</td>
<td>每个 PID namespace 中的进程可以有其独立的 PID， 每个容器可以有其 PID 为 1 的root 进程。</td>
</tr>
<tr>
<td>Network</td>
<td>since linux 3.0</td>
<td>网络相关的系统资源</td>
<td>每个容器用有其独立的网络设备，IP 地址，IP 路由表，/proc/net 目录，端口号等等。</td>
</tr>
<tr>
<td>User</td>
<td>since liux 3.8</td>
<td>用户和组 ID 空间</td>
<td>在 user namespace 中的进程的用户和组 ID 可以和在 host 上不同； 每个 container 可以有不同的 user 和 group id；一个 host 上的非特权用户可以成为 user namespace 中的特权用户；</td>
</tr>
</tbody>
</table>
</div>
<p>由此表可以看到为什么 Docker 会要求 Kernel 版本大于等于 3.8。</p>
<p>在 linux 中会有一个 unshare 工具，这个工具可以运行一些程序从当前进行中 namespace 进行隔离。其 man page 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       unshare - run program with some namespaces unshared from parent</span><br><span class="line">SYNOPSIS</span><br><span class="line">       unshare [options] [program [arguments]]</span><br><span class="line">Options:</span><br><span class="line"> -m, --mount[=&lt;file&gt;]      unshare mounts namespace</span><br><span class="line"> -u, --uts[=&lt;file&gt;]        unshare UTS namespace (hostname etc)</span><br><span class="line"> -i, --ipc[=&lt;file&gt;]        unshare System V IPC namespace</span><br><span class="line"> -n, --net[=&lt;file&gt;]        unshare network namespace</span><br><span class="line"> -p, --pid[=&lt;file&gt;]        unshare pid namespace</span><br><span class="line"> -U, --user[=&lt;file&gt;]       unshare user namespace</span><br><span class="line"> -f, --fork                fork before launching &lt;program&gt;</span><br><span class="line">     --mount-proc[=&lt;dir&gt;]  mount proc filesystem first (implies --mount)</span><br><span class="line"> -r, --map-root-user       map current user to root (implies --user)</span><br><span class="line">     --propagation slave|shared|private|unchanged</span><br><span class="line">                           modify mount propagation in mount namespace</span><br><span class="line"> -s, --setgroups allow|deny  control the setgroups syscall in user namespaces</span><br><span class="line"></span><br><span class="line"> -h, --help     display this help and exit</span><br><span class="line"> -V, --version  output version information and exit</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>CLONE_NEWUTS</strong></p>
<p>在 clone() 函数创建子进程时，CLONE_NEWUTS 标志置位会将使得主机名资源被隔离。两个 UTS 空间的任何改变都不相互影响。这对于虚拟化来讲非常有用，虚拟机管理程序可以给每一个虚拟机创建一个 UTS 空间。</p>
<img src="/2018/12/29/docker_technology-using-linux-namespaces/uts.jpg" class="" alt="NEWUTS">
<p><strong>CLONE_NEWUSER</strong></p>
<p>通过在 clone() 函数中使用 CLONE_NEWUSER 标志，一个单独的 user namespace 就会被创建出来。在新的 user namespace 中会有一个虚拟的用户和用户组的集合。这些用户和用户组，从 uid/gid 0 开始，可以被映射到该 namespace 之外。 </p>
<img src="/2018/12/29/docker_technology-using-linux-namespaces/user.jpg" class="">
<p>上图中，原 user namespace 中 uid:1000 和 gid:1000 被映射到新的 user namespace 中 uid:0 和 gid:0 。尽管在新的 user namespace 中是 root 身份（uid:0，gid:0)，依然不能访问 /root 目录。</p>
<p><strong>CLONE_NEWNS</strong></p>
<p>Mount namespace 用来隔离文件系统的挂载点, 使得不同的 mount namespace 拥有自己独立的挂载点信息，不同的 namespace 之间不会相互影响，当前进程所在 mount namespace 里的所有挂载信息可以在 /proc/[pid]/mounts、/proc/[pid]/mountinfo 和 /proc/[pid]/mountstats 里面找到。每个 mount namespace 都拥有一份自己的挂载点列表，当用 clone 或者 unshare 函数创建新的 mount namespace 时，新创建的 namespace 将拷贝一份老 namespace 里的挂载点列表，但从这之后，他们就没有关系了，通过 mount 和 umount 增加和删除各自 namespace 里面的挂载点都不会相互影响。</p>
<img src="/2018/12/29/docker_technology-using-linux-namespaces/ns.jpg" class="">
<p><strong>CLONE_NEWPID</strong></p>
<p>PID namespaces 用来隔离进程的 ID 空间，使得不同 pid namespace 里的进程 ID 可以重复且相互之间不影响。 PID namespace 可以嵌套，也就是说有父子关系，在当前 namespace 里面创建的所有新的 namespace 都是当前 namespace 的子 namespace。父 namespace 里面可以看到所有子孙后代 namespace 里的进程信息，而子namespace 里看不到祖先或者兄弟 namespace 里的进程信息。</p>
<img src="/2018/12/29/docker_technology-using-linux-namespaces/PID.jpg" class="">
<p>到这里，Docker 容器中进程隔离已经显而易见了，当创建并启动 Docker 容器后 docker start … &amp;&amp; docker exec … 后，容器中进程如下图所示。</p>
<img src="/2018/12/29/docker_technology-using-linux-namespaces/docker_process.png" class="">
<p><strong>CLONE_NEWIPC</strong></p>
<p>IPC namespace用来隔离 System V IPC objects 和POSIX message queues。其中System V IPC objects包含Message queues、Semaphore sets 和 Shared memory segments. </p>
<img src="/2018/12/29/docker_technology-using-linux-namespaces/ipc.jpg" class="">
<p>进入 Docker 环境，除了 docker attach、docker exec 命令，也可用以下命令进行。$PID 为 docker container 的运行进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nsenter --target $PID --mount --uts --ipc --net --pid --user /bin/bash</span><br></pre></td></tr></table></figure>
<p><strong>CLONE_NEWNET</strong></p>
<p>network namespace 用来隔离网络设备, IP地址, 端口等。每个 namespace 将会有自己独立的网络栈，路由表，防火墙规则，socket 等。每个新的 network namespace 默认有一个本地环回接口，除了 lo 接口外，所有的其他网络设备（物理/虚拟网络接口，网桥等）只能属于一个 network namespace。每个 socket 也只能属于一个network namespace。当新的 network namespace 被创建时，lo 接口默认是关闭的，需要自己手动启动起。</p>
<p>Linux container 中用到一个叫做 veth 的东西，这是一种新的设备，专门为 container 所建。veth 从名字上来看是 Virtual ETHernet 的缩写，它的作用很简单，就是要把从一个 network namespace 发出的数据包转发到另一个 namespace。veth 设备是成对的，一个是 container 之中，另一个在 container 之外，即在真实机器上能看到的。 VETH设备总是成对出现。创建并配置正确后，向其一端输入数据，VETH会改变数据的方向并将其送入内核网络子系统，完成数据的注入，而在另一端则能读到此数据。veth工作在L2数据链路层，veth-pair设备在转发数据包过程中并不串改数据包内容。 </p>
<p> 显然，仅有veth-pair设备，容器是无法访问网络的。因为容器发出的数据包，实质上直接进入了veth1设备的协议栈里。如果容器需要访问网络，需要使用bridge等技术，将veth1接收到的数据包通过某种方式转发出去 。</p>
<img src="/2018/12/29/docker_technology-using-linux-namespaces/net.jpg" class="">
<p>在 Docker 中的网络实现基本与此相同。</p>
<img src="/2018/12/29/docker_technology-using-linux-namespaces/docker-veth.png" class="">
<h4 id="3-2-2-Control-Groups"><a href="#3-2-2-Control-Groups" class="headerlink" title="3.2.2 Control Groups"></a>3.2.2 Control Groups</h4><h4 id="3-2-3-Union-Filesystem"><a href="#3-2-3-Union-Filesystem" class="headerlink" title="3.2.3 Union Filesystem"></a>3.2.3 Union Filesystem</h4><h2 id="4-实验"><a href="#4-实验" class="headerlink" title="4. 实验"></a>4. 实验</h2><h3 id="4-1-利用-Linux-中的-Namespace-手工建立容器环境"><a href="#4-1-利用-Linux-中的-Namespace-手工建立容器环境" class="headerlink" title="4.1 利用 Linux 中的 Namespace 手工建立容器环境"></a>4.1 利用 Linux 中的 Namespace 手工建立容器环境</h3><p><strong>Start Terminal 1 (In Container)</strong></p>
<ul>
<li>创建相关目录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@panderan /h/deranpan# mkdir -p /opt/container_root/root/old_root /opt/container_root/data</span><br><span class="line">root@panderan /h/deranpan# cd /opt/container_root      </span><br></pre></td></tr></table></figure>
<ul>
<li>wget 下载 ubuntu 16.04 的根文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@panderan /o/container_root# wget https://raw.githubusercontent.com/tianon/docker-brew-ubuntu-core/dist-amd64/xenial/ubuntu-xenial-core-cloudimg-amd64-root.tar.gz</span><br><span class="line">--2018-12-05 18:14:53--  https://raw.githubusercontent.com/tianon/docker-brew-ubuntu-core/dist-amd64/xenial/ubuntu-xenial-core-cloudimg-amd64-root.tar.gz</span><br><span class="line">Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.108.133</span><br><span class="line">Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.108.133|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 42625208 (41M) [application/octet-stream]</span><br><span class="line">Saving to: ‘ubuntu-xenial-core-cloudimg-amd64-root.tar.gz’</span><br><span class="line"></span><br><span class="line">ubuntu-xenial-core-cloudimg- 100%[===========================================&gt;]  40.65M   876KB/s    in 2m 23s  </span><br><span class="line"></span><br><span class="line">2018-12-05 18:17:18 (290 KB/s) - ‘ubuntu-xenial-core-cloudimg-amd64-root.tar.gz’ saved [42625208/42625208]</span><br></pre></td></tr></table></figure></li>
<li>解压根文件系统到 /opt/container_root/root 目录下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@panderan /o/container_root# cd root &amp;&amp; tar -xf ../ubuntu-xenial-core-cloudimg-amd64-root.tar.gz</span><br><span class="line">root@panderan /o/c/root# cd ..</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">### 利用 unshare 创建命名空间隔离的 bash 进程，进程号为 3664</span><br><span class="line">root@panderan /o/container_root# unshare --mount --uts --ipc --net --pid --user --fork --propagation private /bin/bash</span><br><span class="line">nobody@panderan:/opt/container_root$ ps </span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">  2281 pts/1    00:00:00 zsh</span><br><span class="line">  2518 pts/1    00:00:00 su</span><br><span class="line">  2519 pts/1    00:00:00 zsh</span><br><span class="line">  3663 pts/1    00:00:00 unshare</span><br><span class="line">  3664 pts/1    00:00:00 bash</span><br><span class="line">  3675 pts/1    00:00:00 ps  </span><br></pre></td></tr></table></figure>
<p><strong>Start Terminal 2 (Host)</strong></p>
<ul>
<li>映射 uid 和 gid ，将 host 中的所有 uid，gid 都映射到 Container 中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@panderan /h/deranpan# cd /proc/3664 </span><br><span class="line">root@panderan /p/3664# echo &quot;0 0 4294967295&quot; &gt; gid_map</span><br><span class="line">root@panderan /p/3664# echo &quot;0 0 4294967295&quot; &gt; uid_map</span><br></pre></td></tr></table></figure>
<p><strong>Switch to Terminal 1 (In Container)</strong></p>
<ul>
<li>跟新 bash 可见用户名已经从 nobody 变为 root，并设置新的 hostname 为 container</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nobody@panderan:/opt/container_root$ exec bash</span><br><span class="line">root@panderan:/opt/container_root# hostname container</span><br><span class="line">root@panderan:/opt/container_root# exec bash</span><br><span class="line">root@container:/opt/container_root# </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Switch to Terminal 2 (Host)</strong></p>
<ul>
<li>创建一对 veth 设备，并使用 NAT 使得 Container 能够访问外网。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@panderan /p/3664# ip link add veth0 type veth peer name veth1</span><br><span class="line">root@panderan /p/3664# ip link set veth1 netns 3664 </span><br><span class="line">root@panderan /p/3664# ip addr add dev veth0 192.168.8.1/24</span><br><span class="line">root@panderan /p/3664# ip link set veth0 up        </span><br><span class="line">root@panderan /p/3664# ifconfig veth 0</span><br><span class="line">SIOCSIFADDR: No such device</span><br><span class="line">veth: ERROR while getting interface flags: No such device</span><br><span class="line">root@panderan /p/3664# ifconfig veth0</span><br><span class="line">veth0     Link encap:Ethernet  HWaddr de:b0:75:84:2c:cb  </span><br><span class="line">          inet addr:192.168.8.1  Bcast:0.0.0.0  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line">root@panderan /p/3664# echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">root@panderan /p/3664# iptables -P FORWARD DROP</span><br><span class="line">root@panderan /p/3664# iptables -F FORWARD</span><br><span class="line">root@panderan /p/3664# iptables -t nat -F</span><br><span class="line">root@panderan /p/3664# iptables -t nat -A POSTROUTING -s 192.168.8.0/24 -o ens33 -j MASQUERADE</span><br><span class="line">root@panderan /p/3664# iptables -A FORWARD -i ens33 -o veth0 -j ACCEPT</span><br><span class="line">root@panderan /p/3664# iptables -A FORWARD -o ens33 -i veth0 -j ACCEPT</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Switch to Terminal 1 (In Container)</strong></p>
<ul>
<li>设置 Container 中的网络设备，并添加默认路由</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@container:/opt/container_root# ip link addr add dev veth1 192.168.8.2/24</span><br><span class="line">Command &quot;addr&quot; is unknown, try &quot;ip link help&quot;.</span><br><span class="line">root@container:/opt/container_root# ip addr add dev veth1 192.168.8.2/24            </span><br><span class="line">root@container:/opt/container_root# ip link set veth1 up</span><br><span class="line">root@container:/opt/container_root# ip route add default via 192.168.8.1            </span><br><span class="line">root@container:/opt/container_root# ifconfig veth1</span><br><span class="line">veth1     Link encap:Ethernet  HWaddr 4e:41:2c:4c:21:e1  </span><br><span class="line">          inet addr:192.168.8.2  Bcast:0.0.0.0  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::4c41:2cff:fe4c:21e1/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:30 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:4034 (4.0 KB)  TX bytes:648 (648.0 B)</span><br><span class="line"></span><br><span class="line">root@container:/opt/container_root# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.8.1     0.0.0.0         UG    0      0        0 veth1</span><br><span class="line">192.168.8.0     0.0.0.0         255.255.255.0   U     0      0        0 veth1</span><br><span class="line">root@container:/opt/container_root# </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>测试网络</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@container:/opt/container_root# ping 114.114.114.114</span><br><span class="line">PING 114.114.114.114 (114.114.114.114) 56(84) bytes of data.</span><br><span class="line">64 bytes from 114.114.114.114: icmp_seq=1 ttl=68 time=39.4 ms</span><br><span class="line">64 bytes from 114.114.114.114: icmp_seq=2 ttl=90 time=40.0 ms</span><br><span class="line">64 bytes from 114.114.114.114: icmp_seq=3 ttl=90 time=39.6 ms</span><br><span class="line">64 bytes from 114.114.114.114: icmp_seq=4 ttl=63 time=38.5 ms</span><br><span class="line">^C</span><br><span class="line">--- 114.114.114.114 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3005ms</span><br><span class="line">rtt min/avg/max/mdev = 38.590/39.412/40.009/0.536 ms</span><br><span class="line">root@container:/opt/container_root# </span><br></pre></td></tr></table></figure>
<p><strong>Continue at Terminal 1 (In Container)</strong></p>
<ul>
<li>pivot_root 替换根目录时，新根目录和原根目录不能在一个挂载点。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@container:/opt/container_root# mount --bind root/ root/</span><br></pre></td></tr></table></figure>
<ul>
<li>挂载数据卷，这样切换根目录后任然可以和主机共享文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@container:/opt/container_root# mkdir root/data</span><br><span class="line">root@container:/opt/container_root# mount --bind ./data root/data</span><br></pre></td></tr></table></figure>
<ul>
<li>切换根文件系统，挂载 proc sys dev 目录，并 umount 原根目录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@container:/opt/container_root# mkdir root/old_root</span><br><span class="line">root@container:/opt/container_root# cd root/</span><br><span class="line">root@container:/opt/container_root/root# pivot_root . old_root/</span><br><span class="line">root@container:/opt/container_root/root# exec bash</span><br><span class="line">root@container:/# mount -t proc proc /proc</span><br><span class="line">root@container:/# mount -t sysfs sysfs /sys</span><br><span class="line">root@container:/# mount -t tmpfs tmpfs /dev </span><br><span class="line">root@container:/# umount -l old_root/</span><br><span class="line">root@container:/# </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>查看进程，已与容器外部隔离；data 下也没有数据。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@container:/# ps -ef</span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 10:25 ?        00:00:00 bash</span><br><span class="line">root         70      1  0 11:01 ?        00:00:00 ps -ef</span><br><span class="line">root@container:/# ls /data</span><br><span class="line">root@container:/#</span><br></pre></td></tr></table></figure>
<p><strong>Switch to Terminal 2 (Host)</strong></p>
<ul>
<li>将 sources.list 文件拷贝至主机中的 data 目录中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@panderan /o/container_root# cat ~/sources.list </span><br><span class="line">deb http://mirrors.163.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">root@panderan /o/container_root# cp ~/sources.list /opt/container_root/data  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Switch to Terminal 1 (In Container)</strong></p>
<ul>
<li>将 sources.list 拷贝到 etc 下，并使用 apt 安装 vim 程序。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@container:/# ls /data </span><br><span class="line">sources.list</span><br><span class="line">root@container:/# cp /data/sources.list  /etc/apt/sources.list</span><br><span class="line">root@container:/# echo &quot;nameserver 114.114.114.114&quot; &gt; /etc/resolv.conf</span><br><span class="line">root@container:/# apt update</span><br><span class="line">...</span><br><span class="line">Fetched 18.6 MB in 26s (704 kB/s)</span><br><span class="line">Reading package lists... Done</span><br><span class="line">root@container:/# </span><br><span class="line">root@container:/# apt install vim</span><br><span class="line">...</span><br><span class="line">Processing triggers for libc-bin (2.23-0ubuntu10) ...</span><br><span class="line">root@container:/# vim</span><br></pre></td></tr></table></figure>
<p><strong>Switch to Terminal 2 (Host)</strong></p>
<ul>
<li>观察进程树<br>unshare 创建了子进程bash，bash 又运行刚刚下载安装的 vim</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@panderan /o/container_root# pstree -pl | tail -n 15 | head -n 10</span><br><span class="line">           |-systemd-timesyn(631)---&#123;sd-resolve&#125;(676)</span><br><span class="line">           |-systemd-udevd(356)</span><br><span class="line">           |-thermald(860)---&#123;thermald&#125;(939)</span><br><span class="line">           |-tmux(2280)-+-zsh(2281)---su(2518)---zsh(2519)---unshare(3663)---bash(3664)---vim(7015)</span><br><span class="line">           |            `-zsh(2368)---su(3740)---zsh(3741)-+-head(7445)</span><br><span class="line">           |                                               |-pstree(7443)</span><br><span class="line">           |                                               `-tail(7444)</span><br><span class="line">           |-upowerd(1448)-+-&#123;gdbus&#125;(1452)</span><br><span class="line">           |               `-&#123;gmain&#125;(1451)</span><br><span class="line">           |-vmtoolsd(594)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Start Terminal 3（Get into Container，another bash in container）</strong></p>
<ul>
<li>利用 nsenter 进入容器，并利用 apt 安装 psmisc 后使用 pstree 观察容器内进程树。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@panderan /h/deranpan# nsenter --target 3664 --mount --uts --ipc --net --pid --user bash</span><br><span class="line">root@container:/# apt install psmisc</span><br><span class="line">...</span><br><span class="line">root@container:/# pstree -pl 0</span><br><span class="line">?()-+-bash(1)---vim(529)</span><br><span class="line">    `-bash(598)---pstree(603)</span><br><span class="line">root@container:/# ps -ef</span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 10:25 ?        00:00:00 bash</span><br><span class="line">root        529      1  0 11:09 ?        00:00:00 vim</span><br><span class="line">root        598      0  0 11:22 ?        00:00:00 bash</span><br><span class="line">root        604    598  0 11:23 ?        00:00:00 ps -ef</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，手工创建一个容器到此结束。这个过程简单的利用 Linux 中的 Namespace 隔离机制创建了一个隔离的容器环境。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://draveness.me/docker">Docker 核心技术与实现原理</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.51cto.com/zero01/2074284">容器技术概述</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/精益创业/590883">精益创业</a></li>
<li><a target="_blank" rel="noopener" href="https://gitbook.cn/gitchat/column/5a79594e74fabe0f179f3e8b/topic/5a7959b374fabe0f179f3eb4">聊聊不一样的 DevOps（上）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.51cto.com/zero01/2074284">容器技术概述</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liufei1983/p/7152013.html">DevOps简介</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/GitChat/article/details/79588757">Dev 与 Ops 互怼 | 科普一下 DevOps</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/feilengcui008/article/details/51628366">Linux内核-容器之namespace</a></li>
<li><a target="_blank" rel="noopener" href="http://docker-saigon.github.io/post/Docker-Internals/">Docker Internals</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/sammyliu/p/5878973.html">http://www.cnblogs.com/sammyliu/p/5878973.html</a></li>
<li>Linux Namespace系列</li>
</ol>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/projects_url">项目</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Docker-%E7%AE%80%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1. Docker 简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Docker-%E7%9A%84%E6%8A%80%E6%9C%AF%E6%94%AF%E6%92%91"><span class="toc-number">2.</span> <span class="toc-text">3. Docker 的技术支撑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Docker-vs-Hypervisor"><span class="toc-number">2.1.</span> <span class="toc-text">3.1 Docker vs Hypervisor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Docker-%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF"><span class="toc-number">2.2.</span> <span class="toc-text">3.2 Docker 中的关键技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-Namespaces"><span class="toc-number">2.2.1.</span> <span class="toc-text">3.2.1 Namespaces</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-Control-Groups"><span class="toc-number">2.2.2.</span> <span class="toc-text">3.2.2 Control Groups</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-Union-Filesystem"><span class="toc-number">2.2.3.</span> <span class="toc-text">3.2.3 Union Filesystem</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%9E%E9%AA%8C"><span class="toc-number">3.</span> <span class="toc-text">4. 实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%88%A9%E7%94%A8-Linux-%E4%B8%AD%E7%9A%84-Namespace-%E6%89%8B%E5%B7%A5%E5%BB%BA%E7%AB%8B%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83"><span class="toc-number">3.1.</span> <span class="toc-text">4.1 利用 Linux 中的 Namespace 手工建立容器环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&text=Docker Technology using Linux Namespaces"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&title=Docker Technology using Linux Namespaces"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&is_video=false&description=Docker Technology using Linux Namespaces"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Docker Technology using Linux Namespaces&body=Check out this article: https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&title=Docker Technology using Linux Namespaces"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&title=Docker Technology using Linux Namespaces"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&title=Docker Technology using Linux Namespaces"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&title=Docker Technology using Linux Namespaces"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&name=Docker Technology using Linux Namespaces&description=&lt;p&gt;Docker 是目前广泛应用的容器技术，它将容器内部的环境与主机进行隔离，使得只需分发容器边可运行多种应用程序并且免除了复杂的软件环境配置。在 Docker 中，主要通过 Linux Namespaces 功能来完成对容器和主机多种资源隔离，本文详述了 Linux Namespace 功能，并且演示了如何使勇 unshare 程序手工创建一个隔离环境。&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://panderan.github.io/2018/12/29/docker_technology-using-linux-namespaces/&t=Docker Technology using Linux Namespaces"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2017-2022
    Deran Pan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/projects_url">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->


 
  <link
    rel="preload"
    href="/lib/font-awesome/css/all.min.css"
    as="style"
    onload="this.onload=null;this.rel='stylesheet'"
  />
  <noscript
    ><link
      rel="stylesheet"
      href="/lib/font-awesome/css/all.min.css"
  /></noscript>


    <!-- jquery -->
 
  
<script src="/lib/jquery/jquery.min.js"></script>





<!-- clipboard -->

   
    
<script src="/lib/clipboard/clipboard.min.js"></script>

  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
